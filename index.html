<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>yyyy/mm/dd_hh:mm:ss_丸付き番号 生成ツール</title>
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
<style>
  body { font-family: system-ui, sans-serif; padding: 24px; line-height: 1.6; }
  h1 { font-size: 1.25rem; margin: 0 0 12px; }
  .card { border: 1px solid #e5e7eb; border-radius: 10px; padding: 16px; margin: 12px 0; }
  .row { margin: 8px 0; }
  textarea { width: 100%; min-height: 280px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 14px; }
  button { padding: 8px 12px; border: 1px solid #e5e7eb; border-radius: 8px; cursor: pointer; background: #f9fafb; }
  button + button { margin-left: 8px; }
  .hint { color: #6b7280; font-size: 12px; }
  .ok { color: #16a34a; font-weight: 600; }
  .warn { color: #b45309; font-weight: 600; }
  .err { color: #dc2626; font-weight: 600; }
  .small { font-size: 12px; }
</style>
</head>
<body>
  <h1>yyyy/mm/dd_hh:mm:ss_丸付き番号 生成ツール</h1>

  <div class="card">
    <div class="row">
      <label><strong>① Excelファイルを選択：</strong></label><br/>
      <input type="file" id="file" accept=".xlsx,.xls" />
    </div>
    <div class="row">
      <button id="generateBtn">② リストを作成する</button>
    </div>
    <div class="row small hint">
      想定レイアウト：行0が「日（数値）」、行1が「曜日」、<br/>
      <strong>B列（2列目）に時間</strong>、交点セルに丸付き番号（①〜⑳）。<br/>
      ※B列が空欄の行は、直前の時刻を自動採用します。
    </div>
    <div id="status" class="row small"></div>
  </div>

  <div class="card">
    <div class="row"><strong>出力結果（コピー可能）</strong></div>
    <div class="row">
      <textarea id="output" placeholder="リストがここに表示されます"></textarea>
    </div>
    <div class="row">
      <button id="copyBtn">全てコピー</button>
      <button id="saveBtn">TXTで保存</button>
    </div>
  </div>

<script>
(() => {
  let workbook = null;

  const $file = document.getElementById('file');
  const $output = document.getElementById('output');
  const $status = document.getElementById('status');
  const $generateBtn = document.getElementById('generateBtn');
  const $copyBtn = document.getElementById('copyBtn');
  const $saveBtn = document.getElementById('saveBtn');

  const timeRegex = /^\s*(\d{1,2}):(\d{2})(?::(\d{2}))?\s*$/;     // "14:55" / "14:55:00"
  const circledRegex = /[\u2460-\u2473]/;                          // ①-⑳
  const ymFromSheetName = /(\d{4})\.(\d{1,2})\./;                  // "... 2025.11.02-08"
  const jpWeek = new Set(["日","月","火","水","木","金","土"]);
  const pad2 = n => String(n).padStart(2, '0');

  function detectYearMonthFromSheetName(name) {
    const m = name.match(ymFromSheetName);
    return m ? { year: m[1], month: pad2(m[2]) } : null;
  }

  // Excelの時間セルを HH:MM:SS に正規化（string / number(0-1) / Date 対応）
  function normalizeTime(v) {
    if (v == null) return null;

    if (typeof v === "string") {
      const m = v.match(timeRegex);
      if (!m) return null;
      return `${pad2(m[1])}:${pad2(m[2])}:${pad2(m[3] ?? "00")}`;
    }
    if (typeof v === "number") { // Excelの時刻小数
      if (v < 0 || v > 1) return null;
      const total = Math.round(v * 24 * 3600);
      const hh = pad2(Math.floor(total / 3600) % 24);
      const mm = pad2(Math.floor((total % 3600) / 60));
      const ss = pad2(total % 60);
      return `${hh}:${mm}:${ss}`;
    }
    if (Object.prototype.toString.call(v) === "[object Date]" && !isNaN(v)) {
      return `${pad2(v.getHours())}:${pad2(v.getMinutes())}:${pad2(v.getSeconds())}`;
    }
    return null;
  }

  // NEW: B列（index=1）を上から走査し、直前の時刻で前方埋め
  function buildEffectiveTimes(rows, timeColIdx = 1) {
    const eff = new Array(rows.length).fill(null);
    let last = null;

    for (let r = 0; r < rows.length; r++) {
      const rawVal = rows[r]?.[timeColIdx];
      const norm = normalizeTime(rawVal);
      if (norm) last = norm;   // 新しい時刻を見つけたら更新
      eff[r] = last;           // 見つからなければ直前の時刻を適用
    }
    return eff;
  }

  // 行0の数値 + 行1の曜日で「日列」を確定（B列は除外）
  function collectDayColumns(rows, timeColIdx) {
    const header0 = rows[0] || [];
    const header1 = rows[1] || [];
    const result = [];
    for (let c = 0; c < header0.length; c++) {
      if (c === timeColIdx) continue; // B列(時間列)は除外
      const v0 = header0[c];
      const v1 = header1[c];
      const dayOk = (v0 != null) && /^\d{1,2}$/.test(String(v0).trim());
      const weekdayOk = (v1 != null) && jpWeek.has(String(v1).trim());
      if (dayOk && weekdayOk) {
        result.push({ col: c, day: parseInt(String(v0).trim(), 10) });
      }
    }
    return result;
  }

  function generateList() {
    if (!workbook) {
      $status.innerHTML = `<span class="warn">⚠ ファイルが選択されていません。</span>`;
      return;
    }

    try {
      const sheetName = workbook.SheetNames[0];
      const sheet = workbook.Sheets[sheetName];

      // 値の型を保持したまま配列化（Date/number等を保持）
      const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, raw: true });

      // 年月はシート名から抽出（例: "ブース表 2025.11.02-08" -> 2025/11）
      const ym = detectYearMonthFromSheetName(sheetName);
      if (!ym) throw new Error('シート名から年・月を検出できませんでした（例: "... 2025.11.02-08"）。');

      // B列（0始まり index=1）を時間列として使用
      const timeColIdx = 1;

      // 日列の検出
      const dayCols = collectDayColumns(rows, timeColIdx);
      if (dayCols.length === 0) {
        throw new Error('「日列」が見つかりませんでした（行0に数値、行1に曜日がある列を探しています）。');
      }

      // NEW: B列が空欄の行も直前の時刻を採用（前方埋め）
      const effectiveTimes = buildEffectiveTimes(rows, timeColIdx);

      const out = [];
      let filledCount = 0;
      for (let r = 0; r < rows.length; r++) {
        const rawTime = rows[r]?.[timeColIdx];
        const t = effectiveTimes[r];
        if (!t) continue; // 先頭に時刻が出てくる前の行などはスキップ

        // 前方埋めが効いた行をカウント（任意の可視化）
        if (!normalizeTime(rawTime)) filledCount++;

        for (const { col, day } of dayCols) {
          const v = rows[r]?.[col];
          if (v == null) continue;
          const m = String(v).match(circledRegex);
          if (m) out.push(`${ym.year}/${ym.month}/${pad2(day)}_${t}_${m[0]}`);
        }
      }
      // 並び替え：日付・時間順
        out.sort((a, b) => {
        const parseKey = s => {
            const [date, time] = s.split("_");
            const [y, m, d] = date.split("/").map(Number);
            const [hh, mm, ss] = time.split(":").map(Number);
            return new Date(y, m - 1, d, hh, mm, ss).getTime();
        };
        return parseKey(a) - parseKey(b);
        });

      // ステータス表示
      $output.value = out.join('\n');
      const dbg = [
        `<span class="small hint">年/月: ${ym.year}/${ym.month}（シート名から抽出）</span>`,
        `<span class="small hint">時間列: B列（index=${timeColIdx}）を使用（前方埋め ${filledCount} 行）</span>`,
        `<span class="small hint">検出した日列: ${dayCols.map(d=>`[col:${d.col}, day:${d.day}]`).join(', ')}</span>`
      ].join('<br/>');
      const ok = `<span class="ok">✓ 完了</span> ${out.length} 件を生成しました。`;
      $status.innerHTML = ok + '<br/>' + dbg;

      if (out.length === 0) {
        $status.innerHTML += `<br/><span class="warn">⚠ 丸付き番号のある交点セルが見つかりませんでした。</span>`;
      }
    } catch (e) {
      $status.innerHTML = `<span class="err">エラー:</span> ${e.message}`;
      console.error(e);
    }
  }

  // ファイル選択（読み込みのみ、作成はボタン押下時）
  document.getElementById('file').addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    try {
      const buf = await file.arrayBuffer();
      // cellDates:true で Date としても受け取れるように
      workbook = XLSX.read(buf, { cellText: false, cellDates: true });
      $status.innerHTML = `<span class="ok">✓</span> ${file.name} を読み込みました。`;
    } catch (err) {
      console.error(err);
      $status.innerHTML = `<span class="err">エラー:</span> ファイルの読み込みに失敗しました。`;
    }
  });

  document.getElementById('generateBtn').addEventListener('click', generateList);

  document.getElementById('copyBtn').addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText($output.value);
      $copyBtn.textContent = 'コピーしました';
      setTimeout(() => ($copyBtn.textContent = '全てコピー'), 1200);
    } catch {}
  });

  document.getElementById('saveBtn').addEventListener('click', () => {
    const blob = new Blob([$output.value], { type: 'text/plain;charset=utf-8' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'export.txt';
    a.click();
    URL.revokeObjectURL(a.href);
  });
})();
</script>
</body>
</html>
